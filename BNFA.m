function [Phat,Ahat,Sigmahat,stdP,stdA,stdSigma,PSnor,ASnor,SigmaS]=BNFA(Y,q,muP,nBurnIn,nIter,nThin,errdist,df,varP_free,xi,Omega,a0,b0,alpha,species_name);%-----------------------------------------------------------------------% BNFA.m% : MATLAB function for performing Bayesian Nonnegative Factor Analysis%-----------------------------------------------------------------------%%                               BNFA v.1.1%% This function implements Bayesian Nonnegative Factor Analysis (BNFA)% including Bayesian multivariate receptor modeling and% robust Bayesian multivariate receptor modeling by Markov chain Monte% Carlo (MCMC) methods.%% Author: Eun Sug Park, Man-Suk Oh% Maintainer: Eun Sug Park (e-park@tti.tamu.edu)% Date: 2020-09-07% Last updated: 2021-02-12%% Need the following m-files in the same folder (or in the MATLAB work folder):% BNFA.m (main function)% BNFA_input.m (optional)% Gen_mvn_truncated.m% idCond_check.m% pcplot.m% barplotP.m% tsplotA.m% traceplot.m% traceplot_ACF_P.m% traceplot_ACF_A.m% traceplot_ACF_Sigma.m%% Usage example:% [Phat,Ahat,Sigmahat]=BNFA(Y,q,muP);% [Phat,Ahat,Sigmahat,stdP,stdA,stdSigma]=BNFA(Y,q,muP);% [Phat,Ahat,Sigmahat,stdP,stdA,stdSigma]=BNFA(Y,q,muP,nBurnIn,nIter,nThin);% [Phat,Ahat,Sigmahat,stdP,stdA,stdSigma]=BNFA(Y,q,muP,nBurnIn,nIter,nThin,errdist,df,varP_free,xi,Omega,a0,b0,alpha);% [Phat,Ahat,Sigmahat,stdP,stdA,stdSigma,PSnor,ASnor,SigmaS]=BNFA(Y,q,muP);% [Phat,Ahat,Sigmahat,stdP,stdA,stdSigma,PSnor,ASnor,SigmaS]=BNFA(Y,q,muP,nBurnIn,nIter,nThin);% [Phat,Ahat,Sigmahat,stdP,stdA,stdSigma,PSnor,ASnor,SigmaS]=BNFA(Y,q,muP,nBurnIn,nIter,nThin,errdist,df,varP_free,xi,Omega,a0,b0,alpha);% If species_name (J-dimensional string vector containing variable names) is% available in the workspace, the following call format can also be used:% [Phat,Ahat,Sigmahat,stdP,stdA,stdSigma,PSnor,ASnor,SigmaS]=BNFA(Y,q,muP,nBurnIn,nIter,nThin,errdist,df,varP_free,xi,Omega,a0,b0,alpha,species_name);% % Inputs:% Y: T by J data matrix (T: number of observations, J: number of variables)% (Observations containing missing values are removed.)% q: number of factors (number of major pollution sources)% muP: prior mean matrix (of size q by J) for the source composition matrix P% where zero values are assigned to prespecified elements of muP to satisfy % the identifiability conditions.% For the remaining free elements, nonnegative numbers can be assigned% (default=0.5).% nBurnIn: number of iterations for the burn-in period in MCMC (default=5000)% nIter: number of iterations in the sampling phase of MCMC% (i.e., after burn-in) for monitoring samples from MCMC (default=5000)% nThin: thinning interval for monitoring samples from MCMC (default=1)% errdist: error distribution. Type 't' for t-distribution, 'normal' for normal distribution.% df: degrees of freedom of a t-distribution when a t-distribution is assumed for errors (default=4)% varP_free: value of the prior variance of the free (non-zero) elements of P (default=100)% xi: prior mean vector of the q-dimensional source contribution% Omega: diagonal matrix of the prior variance of the q-dimensional source contribution% a0: shape parameter of the Inverse Gamma prior of the error variance (default=0.01)% b0: scale parameter of the Inverse Gamma prior of the error variance (default=0.01*ones(J,1))% alpha: level for the posterior intervals (default=0.05)% For example, alpha = 0.05 results in 95% posterior intervals.% species_name (optional): J-dimensional string vector containing variable (species) names %% Outputs:% [Estimates: point estimates and uncertainty estimates]% Phat: estimated source composition matrix% Ahat: estiamted source contribution matrix% Sigmahat: estimated error variances (estimated diagonal elements of Sigma)% stdP,stdA,stdSigma: posterior standard deviations for P, A, and% diag(Sigma), respectively.%% [Stored MCMC samples]% PSnor: 3-dimensional array of MCMC samples for elements of P (q by J by nsample)% (nsample: number of stored samples)% ASnor: 3-dimensional array of MCMC samples for elements of A (T by q by nsample)% SigmaS: 2-dimensional array of MCMC samples for diagonal elements of Sigma (nsample by J)%  % [Plots]% Principal component plots of data (Y) and Phat% Bar plots for elements of Phat with error bars (95% posterior intervals)% Time series plots of Ahat along with 95% posterior intervals% Trace plots for MCMC samples of P, A, and diag(Sigma) % Side by side trace plots and ACF plots (along with ESS) for MCMC samples of P, A, and diag(Sigma) %% The user is free to use this program as long as it is not modified and % appropriate acknowledgement is given.%% Reference: Park, E.S. and Oh, M.S. (2015),% Robust Bayesian Multivariate Receptor Modeling,% CHEMOMETRICS AND INTELLIGENT LABORATORY SYSTEMS,149, 215-226.%---------------------------------------------------------------------Y(any(isnan(Y)'),:)=[]; %Remove any rows of Y with missing values (NaNs) [T,J]=size(Y); %size of data (after removing the rows with missing values)if nargin==3    nBurnIn=5000;nIter=5000;nThin=1;  %default values    errdist='normal'; df=4; varP_free=100;    xi=ones(1,q);Omega=eye(q);a0=0.01;b0=0.01*ones(J,1);alpha=0.05;elseif nargin==4    nIter=5000;nThin=1;    errdist='normal'; df=4; varP_free=100;    xi=ones(1,q);Omega=eye(q);a0=0.01;b0=0.01*ones(J,1);alpha=0.05;elseif nargin==5    nThin=1;errdist='normal'; df=4; varP_free=100;    xi=ones(1,q);Omega=eye(q);a0=0.01;b0=0.01*ones(J,1);alpha=0.05;elseif nargin==6    errdist='normal'; df=4; varP_free=100;    xi=ones(1,q);Omega=eye(q);a0=0.01;b0=0.01*ones(J,1); alpha=0.05;elseif nargin==7    df=4; varP_free=100;    xi=ones(1,q);Omega=eye(q);a0=0.01;b0=0.01*ones(J,1); alpha=0.05;elseif nargin==8    varP_free=100;    xi=ones(1,q);Omega=eye(q);a0=0.01;b0=0.01*ones(J,1);alpha=0.05;elseif nargin==9    xi=ones(1,q);Omega=eye(q);a0=0.01;b0=0.01*ones(J,1); alpha=0.05;elseif nargin==10    Omega=eye(q);a0=0.01;b0=0.01*ones(J,1); alpha=0.05;elseif nargin==11    a0=0.01;b0=0.01*ones(J,1);alpha=0.05;elseif nargin==12    b0=0.01*ones(J,1);alpha=0.05;elseif nargin==13    alpha=0.05;end%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%H=nBurnIn+nIter;  %Total run length for preliminary MCMC runsBi=nBurnIn;      %Burn-in timemstep=nThin;	%subsampling lagnsample=(H-Bi)/mstep;	%number of posterior samples stored%---------------------------------------------% Prior distributions%----------------------------------------------%---------------------------------------------%prior for P: vecP_0~Truncated Normal(c0_0,C0_0)%---------------------------------------------%muP: prior mean of P matrix with prespecification of zero constraints enforced.%Default value for free elements of P: 0.5zeroindexP=find(muP==0);nonzeroindexP=find(muP~=0);dimP=length(nonzeroindexP);if length(zeroindexP)<q*(q-1)    msg = 'Identifiability condition C1 (prespecification of at least q-1 zero elements in each row) is not satisfied for muP.';    warning(msg)endc0=reshape(muP,q*J,1); %vector form of muP, i.e., prior mean of vec(P)C0=varP_free*eye(q*J); %covariance of normal prior of vec(P)%---------------------------------------------%prior for A: A_t~Normal(xi,Omega)%---------------------------------------------%default:%xi=ones(1,q);%Omega=eye(q);invOmega=inv(Omega);%---------------------------------------------%Prior for Sigma: inverse gamma (a0, b0)%(parameterization: mean a0/b0)%---------------------------------------------%default:%a0=0.01;%b0=0.01*ones(J,1);%-----------------------------------------% distribution (IG) for latent variable kappa%-----------------------------------------%df: Degrees of freedom for T%default%df=4;alpha_k=df/2;beta_k=df/2;tict1=fix(clock)%------------------------------------------------------------%Initial value for P, A, and Sigma%------------------------------------------------------------P_initial=rand(q,J);P_initial(find(muP==0))=0;P=P_initial;A_initial=Y*P'*inv(P*P');A_initial(A_initial<0)=0;A=A_initial;Sigma_initial=eye(J);Sigma=Sigma_initial;diagSigma=diag(Sigma);  %diagonal elements of SigmainvSigma=inv(Sigma);kappa=ones(T,1);if errdist=='t'    kappa_initial=3*rand(T,1);    kappa=kappa_initial;endMkappa=diag(kappa);ikappa=1./kappa;invMkappa=diag(ikappa);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%PS=zeros(q,J,nsample);AS=zeros(T,q,nsample);SigmaST=zeros(J,nsample);ii=1;for h=1:H			%Start MCMC        %----------------------------------    %Full conditional posterior for A    %-----------------------------------        for t=1:T        ikappa_t=1/kappa(t);        V_A_t=inv(invOmega+P*ikappa_t*invSigma*P');        m_A_t=(Y(t,:)*ikappa_t*invSigma*P'+xi*invOmega)*V_A_t;        A(t,:)=Gen_mvn_truncated(q,A(t,:),m_A_t,V_A_t,zeros(q,1),Inf*ones(q,1));    end          %------------------------------------------------------------    %Full conditional posterior for P     % (Truncated) Normal (c,C)    %-----------------------------------------------    for j=1:J        C0j=C0((q*(j-1)+1):(q*(j-1)+q),(q*(j-1)+1):(q*(j-1)+q));        %Free_elt=find(muP(:,j)~=0 & muP(:,j)~=1);        Free_elt=find(muP(:,j)~=0);        dimPj=length(Free_elt);        if dimPj>0            Areduced=A(:,Free_elt);            Cj=inv(inv(C0j(Free_elt,Free_elt))+1/diagSigma(j)*Areduced'*invMkappa*Areduced);            mj=Cj*(inv(C0j(Free_elt,Free_elt))*muP(Free_elt,j)+1/diagSigma(j)*Areduced'*invMkappa*Y(:,j));            P(Free_elt,j)=Gen_mvn_truncated(dimPj, P(Free_elt,j),mj,Cj,zeros(dimPj,1),Inf*ones(dimPj,1));        end  %end if dimPj>0    end        %---------------------    %Full conditional posterior for the diagonal elements of Sigma (diagSigma)    %Inverse Gamma (a0+0.5*T, b0+0.5*d_j)    %----------------------------------    d=diag((Y-A*P)'*invMkappa*(Y-A*P));    G=gamrnd(T/2+a0, 1./(b0+d/2));    diagSigma=1./G;	%posterior: Inverse gamma    Sigma=diag(diagSigma);%J by J matrix    invSigma=diag(G);%inv(Sigma);    %---------------------        if errdist=='t'        %-------------------------------------------        % Full conditional posterior for kappa        %-------------------------------------------        Dn=diag((Y-A*P)*invSigma*(Y-A*P)');        G_kappa=gamrnd(J/2+alpha_k, 1./(beta_k+Dn/2));        kappa=1./G_kappa;	%Inverse gamma        invMkappa=diag(G_kappa);    end        if h>Bi        if h==Bi+mstep*(ii-1)+1            %Store MCMC samples after the burn-inSigmaS            PS(:,:,ii)=P;            AS(:,:,ii)=A;            SigmaST(:,ii)=diagSigma;	 %Store the diagonal elements of Sigma            ii=ii+1;        end  %End if h==Bi+mstep*(ii-1)+1    end  %End if h>Biend	   %End of preliminary MCMC samplingtoct2=fix(clock)%--------------------------------------------%BNFA_postprocessing:%Postprocess the stored MCMC samples of P and A%so that P satisfies the row-sum-to-one constraint%and A is scaled accordingly.%-----------------------------------------------PSnor=zeros(q,J,nsample); %3-dimensional arrayASnor=zeros(T,q,nsample); %3-dimensional arrayfor hh=1:nsample    P_hh=PS(:,:,hh);    NC_P_hh=sum(P_hh');    D_NC_P_hh=diag(NC_P_hh);    I_NC_P_hh=diag(1./NC_P_hh);    P_normalized_hh=I_NC_P_hh*P_hh;    PSnor(:,:,hh)=P_normalized_hh;    ASnor(:,:,hh)=(AS(:,:,hh))*D_NC_P_hh;endvecPS=reshape(PSnor,q*J,nsample)'; %nsample by qJ%---------------------------------------------% vecPS: 2-dimensional array of stored MCMC samples for elements of P %---------------------------------------------vmeanP=mean(vecPS);meanP=reshape(vmeanP,q,J);vstdP=std(vecPS);stdP=reshape(vstdP,q,J);vmedianP=median(vecPS);medianP=reshape(vmedianP,q,J);vecAS=reshape(ASnor,T*q,nsample)'; %nsample by Tq%---------------------------------------------% vecAS: 2-dimensional array of stored MCMC samples for elements of A %---------------------------------------------vmeanA=mean(vecAS);meanA=reshape(vmeanA,T,q);vstdA=std(vecAS);stdA=reshape(vstdA,T,q);vmedianA=median(vecAS);medianA=reshape(vmedianA,T,q);%-------------------------------------------------%Estimate of P, A, and diagSigma%-------------------------------------------------note='Estimated source composition matrix (P):'Phat=meanP %<--Point estmate for PstdP=stdP  %<--Uncertainty estimates for Phat[Phat_sub_rank,length_II]=idCond_check(Phat);if length_II<q*(q-1)    msg = 'Identifiability condition C1 is not satisfied for Phat.';    warning(msg)endif  prod(Phat_sub_rank==q-1)~=1    msg = 'Identifiability condition C2 is not satisfied for Phat.';    warning(msg)endnote='Estimated source contributions (A) displayed up to 10 time points:'Ahat=meanA; %<--Point estmate for AAhat_t1_t10=Ahat(1:10,:)stdA=stdA;  %<--Uncertainty estimates for AhatstdA_t1_t10=stdA(1:10,:)SigmaS=SigmaST';%---------------------------------------------% SigmaS: 2-dimensional array of stored MCMC samples for diagonal elements of Sigma % (nsample by J)%---------------------------------------------note='Estimated error variances (diag(Sigma)):'meanSigma=mean(SigmaS);Sigmahat=meanSigma %<--Point estmate for diagonal elements of SigmastdSigma=std(SigmaS) %<--Uncertainty estimates for Sigmahat%-------------------------------------------------%Compute 100*(1-alpha)% (default: 95%) posterior intervals for P%-------------------------------------------------index_L=floor(alpha/2*nsample);index_U=ceil((1-alpha/2)*nsample);sortedPnor=sort(vecPS);PI_P=sortedPnor([index_L index_U],:); %PI: Posterior Intervalnote='Lower and Upper limits of the (95%) posterior interval for P:'LL_P=reshape(PI_P(1,:),q,J) %Lower limit of PI for PUL_P=reshape(PI_P(2,:),q,J) %Upper limit of PI for Pnote='(95%) Posterior interval widths for elements of P:';PI_width_P=(UL_P-LL_P); %-------------------------------------------------%Compute 100*(1-alpha)% (default: 95%) posterior intervals for A%-------------------------------------------------sortedAnor=sort(vecAS);PI_A=sortedAnor([index_L index_U],:);LL_A=reshape(PI_A(1,:),T,q);  %Lower limit of PI for AUL_A=reshape(PI_A(2,:),T,q);  %Upper limit of PI for Anote='Lower and Upper limits of the (95%) posterior interval for A (displayed up to 10 time points):'LL_A_t1_t10=LL_A(1:10,:)UL_A_t1_t10=UL_A(1:10,:)PI_width_A=UL_A-LL_A;note='Average (95%) posterior interval widths (over all time points) for elements of A:';avg_A_PI_width=mean(PI_width_A);%-------------------------------------------------%Compute 100*(1-alpha)% (default: 95%) posterior intervals for diagSigma%-------------------------------------------------sorted_diagSigma=sort(SigmaS);PI_diagSigma=sorted_diagSigma([index_L index_U],:);note='Lower and Upper limits of the (95%) posterior interval for diag(Sigma):'LL_diagSigma=PI_diagSigma(1,:) %Lower limit of PI for SigmaUL_diagSigma=PI_diagSigma(2,:) %Upper limit of PI for Sigmanote='(95%) Posterior interval widths for diag(Sigma):';PI_width_diagSigma=UL_diagSigma-LL_diagSigma;%--------------------------------------------------------------------------% BNFA plots: pcplot, barplot, tsplot, traceplot, trace_ACF_plot_P,% trace_ACF_plot_A, trace_ACF_plot_Sigma%--------------------------------------------------------------------------% ---------------------------------------------------------------%Principal component plots of data (Y) and source profiles (Phat)%-----------------------------------------------------------------pcplot(Y,Phat)%---------------------------------------------------------------% Barplots for elements of the estimated source profiles (Phat)% with error bars (95% posterior intervals)%---------------------------------------------------------------if nargin<15    barplotP(PSnor,alpha);elseif nargin==15    %If species_name (J-dimensional vector containing the variable names) is    %available in the workspace, the following call format can also be used:    barplotP(PSnor,alpha,species_name);end%---------------------------------------------------------------% Time series plots of the estimated source contributions (Ahat)% with 95% posterior intervals%-------------------------------------------------------------tsplotA(ASnor,alpha);%---------------------------------------------------------------% Trace plots of MCMC samples for P, A, and diag(Sigma)%---------------------------------------------------------------nrow=4; ncol=4; %Number of rows and columns for subplots per window (page).%<--Different numbers can be used.k=1; %Source number for producing traceplots for A (default=1)%<--k can be changed to any number between 1 and q.traceplot(nrow,ncol,PSnor,ASnor,k,SigmaS);%<--k can be changed to any number between 1 and q.%---------------------------------------------------------------% Trace plots and ACF plots along with ESS of MCMC samples for % elements of P, A, and Sigma for monitoring convergence and autocorrelation%---------------------------------------------------------------nrow=3; %Number of rows for subplots per window (page)ncol_even=4; %Number of columns for subplots per window (page).%<--Use an even number for ncol_even. (Either 2 or 4 is the best.)traceplot_ACF_P(PSnor,nrow,ncol_even);k=1; %Source number for producing traceplots for A (default=1)%<--k can be changed to any number between 1 and q.traceplot_ACF_A(ASnor,k,nrow,ncol_even);traceplot_ACF_Sigma(SigmaS,nrow,ncol_even);% Type 'close all' to close all figure windows.