function [Phat,Ahat,DSigmahat,stdP,stdA,stdDSigma,PSnor,ASnor,DSigmaS]=BNFA(Y,q,muP,nBurnIn,nIter,nThin,errdist,df,varP_free,xi,Omega,a0,b0,alpha,species_name);%-----------------------------------------------------------------------% BNFA.m% : MATLAB function for performing Bayesian Nonnegative Factor Analysis%-----------------------------------------------------------------------%%                               BNFA v.1.0%% This function implements Bayesian Nonnegative Factor Analysis (BNFA)% including Bayesian multivariate receptor modeling and% robust Bayesian multivariate receptor modeling by Markov chain Monte% Carlo (MCMC) methods.%% Author: Eun Sug Park, Man-Suk Oh% Maintainer: Eun Sug Park (e-park@tti.tamu.edu)% Date: 2020-09-07%% Need the following m-files in the same folder (or in the MATLAB work folder):% BNFA.m (main function)% Gen_mvn_truncated.m% idCond_check.m% pcplot.m% barplotP.m% tsplotA.m% traceplot_ACF_P.m% traceplot.m% BNFA_input.m (optional)%% Usage example:% [Phat,Ahat,DSigmahat]=BNFA(Y,q,muP);% [Phat,Ahat,DSigmahat,stdP,stdA,stdDSigma]=BNFA(Y,q,muP);% [Phat,Ahat,DSigmahat,stdP,stdA,stdDSigma]=BNFA(Y,q,muP,nBurnIn,nIter,nThin);% [Phat,Ahat,DSigmahat,stdP,stdA,stdDSigma]=BNFA(Y,q,muP,nBurnIn,nIter,nThin,errdist,df,varP_free,xi,Omega,a0,b0,alpha);% [Phat,Ahat,DSigmahat,stdP,stdA,stdDSigma,PSnor,ASnor,DSigmaS]=BNFA(Y,q,muP,nBurnIn,nIter,nThin,errdist,df,varP_free,xi,Omega,a0,b0,alpha);% If species_name (J-dimensional vector containing the variable names) is% available in the workspace, the following call format can also be used:% [Phat,Ahat,DSigmahat,stdP,stdA,stdDSigma,PSnor,ASnor,DSigmaS]=BNFA(Y,q,muP,nBurnIn,nIter,nThin,errdist,df,varP_free,xi,Omega,a0,b0,alpha,species_name);%% Inputs:% Y: T by J data matrix (T: number of observations, J: number of variables)% (Observations containing missing values are removed.)% q: number of factors (number of major pollution sources)% muP: prior mean matrix (of size q by J) for the source composition matrix P% where zero values are assigned to prespecified elements of muP to satisfy % the identifiability conditions.% For the remaining free elements, nonnegative numbers can be assigned% (default=0.5).% nBurnIn: number of iterations for the burn-in period in MCMC (default=5000)% nIter: number of iterations in the sampling phase of MCMC% (i.e., after burn-in) for monitoring samples from MCMC (default=5000)% nThin: thinning interval for monitoring samples from MCMC (default=1)% errdist: error distribution. Type 't' for t-distribution, 'normal' for normal distribution.% df: degrees of freedom of a t-distribution when a t-distribution is assumed for errors (default=4)% varP_free: value of the prior variance of the free (non-zero) elements of P (default=100)% xi: prior mean vector of the q-dimensional source contribution% Omega: diagonal matrix of the prior variance of the q-dimensional source contribution% a0: shape parameter of the Inverse Gamma prior of the error variance (default=0.01)% b0: scale parameter of the Inverse Gamma prior of the error variance (default=0.01)% alpha: level for the posterior intervals (default=0.05)% For example, alpha = 0.05 results in 95% posterior intervals.% species_name: J-dimensional vector containing the variable names (optional)%% Outputs:% [Estimates]% Phat: estimated source composition matrix% Ahat: estiamted source contribution matrix% DSigmahat: estimated error variances (diagonal elements of Sigmahat)% stdP,stdA,stdDSigma: posterior standard deviations for P, A, and% diag(Sigma), respectively.% [Stored MCMC samples: optional]% PSnor: MCMC samples for the elements of source composition matrix (P)% ASnor: MCMC samples for the elements of source contribution matrix (A)% DSigmaS: MCMC samples for error variances (diag(Sigma))% [Plots]% Principal component plots of data (Y) and Phat% Bar plots for elements of Phat with error bars (95% posterior intervals)% Time series plots of Ahat along with 95% posterior intervals% Trace and ACF plots of MCMC samples for P for monitoring convergence% Trace plots of MCMC samples for A and DSigma for monitoring convergence%% The user is free to use this program as long as it is not modified and % appropriate acknowledgement is given.%% Reference: Park, E.S. and Oh, M.S. (2015),% Robust Bayesian Multivariate Receptor Modeling,% CHEMOMETRICS AND INTELLIGENT LABORATORY SYSTEMS,149, 215-226.%---------------------------------------------------------------------Y(any(isnan(Y)'),:)=[]; %Remove any rows of Y with missing values (NaNs) [T,J]=size(Y); %size of data (after removing the rows with missing values)if nargin==3    nBurnIn=5000;nIter=5000;nThin=1;  %default values    errdist='normal'; df=4; varP_free=100;    xi=ones(1,q);Omega=eye(q);a0=0.01;b0=0.01*ones(J,1);alpha=0.05;elseif nargin==4    nIter=5000;nThin=1;    errdist='normal'; df=4; varP_free=100;    xi=ones(1,q);Omega=eye(q);a0=0.01;b0=0.01*ones(J,1);alpha=0.05;elseif nargin==5    nThin=1;errdist='normal'; df=4; varP_free=100;    xi=ones(1,q);Omega=eye(q);a0=0.01;b0=0.01*ones(J,1);alpha=0.05;elseif nargin==6    errdist='normal'; df=4; varP_free=100;    xi=ones(1,q);Omega=eye(q);a0=0.01;b0=0.01*ones(J,1); alpha=0.05;elseif nargin==7    df=4; varP_free=100;    xi=ones(1,q);Omega=eye(q);a0=0.01;b0=0.01*ones(J,1); alpha=0.05;elseif nargin==8    varP_free=100;    xi=ones(1,q);Omega=eye(q);a0=0.01;b0=0.01*ones(J,1);alpha=0.05;elseif nargin==9    xi=ones(1,q);Omega=eye(q);a0=0.01;b0=0.01*ones(J,1); alpha=0.05;elseif nargin==10    Omega=eye(q);a0=0.01;b0=0.01*ones(J,1); alpha=0.05;elseif nargin==11    a0=0.01;b0=0.01*ones(J,1);alpha=0.05;elseif nargin==12    b0=0.01*ones(J,1);alpha=0.05;elseif nargin==13    alpha=0.05;end%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%H=nBurnIn+nIter;  %Total run length for preliminary MCMC runsBi=nBurnIn;      %Burn-in timemstep=nThin;	%subsampling lagmcsize=(H-Bi)/mstep;	%Size of the stored sample%---------------------------------------------% Prior distributions%----------------------------------------------%---------------------------------------------%prior for P: vecP_0~Truncated Normal(c0_0,C0_0)%---------------------------------------------%muP: prior mean of P matrix with prespecification of zero constraints enforced.%Default value for free elements of P: 0.5zeroindexall=find(muP==0);nonzeroindexall=find(muP~=0);dimP=length(nonzeroindexall);if length(zeroindexall)<q*(q-1)    msg = 'Identifiability condition C1 (prespecification of at least q-1 zero elements in each row) is not satisfied for muP.';    warning(msg)endc0=reshape(muP,q*J,1); %vector form of muP, i.e., prior mean of vec(P)C0=varP_free*eye(q*J); %covariance of normal prior of vec(P)%---------------------------------------------%prior for A: A_t~Normal(xi,Omega)%---------------------------------------------%default:%xi=ones(1,q);%Omega=eye(q);invOmega=inv(Omega);%---------------------------------------------%Prior for Sigma: inverse gamma (a0, b0)%(parameterization: mean a0/b0)%---------------------------------------------%default:%a0=0.01;%b0=0.01*ones(J,1);%-----------------------------------------% distribution (IG) for latent variable kappa%-----------------------------------------%df: Degrees of freedom for T%default%df=4;alpha_k=df/2;beta_k=df/2;tict1=fix(clock)%------------------------------------------------------------%Initial value for P, A, and Sigma%------------------------------------------------------------P_initial=rand(q,J);P_initial(find(muP==0))=0;P=P_initial;A_initial=Y*P'*inv(P*P');A_initial(A_initial<0)=0;A=A_initial;Sigma_initial=eye(J);Sigma=Sigma_initial;DSigma=diag(Sigma);  %diagonal elements of SigmainvSigma=inv(Sigma);kappa=ones(T,1);if errdist=='t'    kappa_initial=3*rand(T,1);    kappa=kappa_initial;endMkappa=diag(kappa);ikappa=1./kappa;invMkappa=diag(ikappa);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%PS=zeros(q,J,mcsize);AS=zeros(T,q,mcsize);DSigmaS=zeros(J,mcsize);ii=1;for h=1:H			%Start MCMC        %----------------------------------    %Full conditional posterior for A    %-----------------------------------        for t=1:T        ikappa_t=1/kappa(t);        V_A_t=inv(invOmega+P*ikappa_t*invSigma*P');        m_A_t=(Y(t,:)*ikappa_t*invSigma*P'+xi*invOmega)*V_A_t;        A(t,:)=Gen_mvn_truncated(q,A(t,:),m_A_t,V_A_t,zeros(q,1),Inf*ones(q,1));    end          %------------------------------------------------------------    %Full conditional posterior for P (BlockMH)    % (Truncated) Normal (c,C)    %-----------------------------------------------    for j=1:J        C0j=C0((q*(j-1)+1):(q*(j-1)+q),(q*(j-1)+1):(q*(j-1)+q));        Free_elt=find(muP(:,j)~=0 & muP(:,j)~=1);        dimPj=length(Free_elt);        if dimPj>0            Areduced=A(:,Free_elt);            Cj=inv(inv(C0j(Free_elt,Free_elt))+1/DSigma(j)*Areduced'*invMkappa*Areduced);            mj=Cj*(inv(C0j(Free_elt,Free_elt))*muP(Free_elt,j)+1/DSigma(j)*Areduced'*invMkappa*Y(:,j));            P(Free_elt,j)=Gen_mvn_truncated(dimPj, P(Free_elt,j),mj,Cj,zeros(dimPj,1),Inf*ones(dimPj,1));        end  %end if dimPj>0    end        %---------------------    %Full conditional posterior for the diagonal elements of Sigma (DSigma)    %Inverse Gamma (a0+0.5*T, b0+0.5*d_j)    %----------------------------------    d=diag((Y-A*P)'*invMkappa*(Y-A*P));    G=gamrnd(T/2+a0, 1./(b0+d/2));    DSigma=1./G;	%posterior: Inverse gamma    Sigma=diag(DSigma);%J by J matrix    invSigma=diag(G);%inv(Sigma);    %---------------------        if errdist=='t'        %-------------------------------------------        % Full conditional posterior for kappa        %-------------------------------------------        Dn=diag((Y-A*P)*invSigma*(Y-A*P)');        G_kappa=gamrnd(J/2+alpha_k, 1./(beta_k+Dn/2));        kappa=1./G_kappa;	%Inverse gamma        invMkappa=diag(G_kappa);    end        if h>Bi        if h==Bi+mstep*(ii-1)+1            %Store MCMC samples after the burn-in            PS(:,:,ii)=P;            AS(:,:,ii)=A;            DSigmaS(:,ii)=DSigma;	 %Store the diagonal elements of Sigma            ii=ii+1;        end  %End if h==Bi+mstep*(ii-1)+1    end  %End if h>Biend	   %End of preliminary MCMC samplingtoct2=fix(clock)%--------------------------------------------%BNFA_postprocessing:%Postprocess the stored MCMC samples of P and A%so that P satisfies the row-sum-to-one constraint%and A is scaled accordingly.%-----------------------------------------------PSnor=zeros(q,J,mcsize);ASnor=zeros(T,q,mcsize);for hh=1:mcsize    P_hh=PS(:,:,hh);    NC_P_hh=sum(P_hh');    D_NC_P_hh=diag(NC_P_hh);    I_NC_P_hh=diag(1./NC_P_hh);    P_normalized_hh=I_NC_P_hh*P_hh;    PSnor(:,:,hh)=P_normalized_hh;    ASnor(:,:,hh)=(AS(:,:,hh))*D_NC_P_hh;endvecPnor=reshape(PSnor,q*J,mcsize);vmeanPnor=mean(vecPnor');meanPnor=reshape(vmeanPnor, q,J);vstdPnor=std(vecPnor');stdPnor=reshape(vstdPnor, q,J);vecAnor=reshape(ASnor,T*q,mcsize);vmeanAnor=mean(vecAnor');meanAnor=reshape(vmeanAnor,T,q);vstdAnor=std(vecAnor');stdAnor=reshape(vstdAnor,T,q);vmedianAnor=median(vecAnor');medianAnor=reshape(vmedianAnor,T,q);%-------------------------------------------------%Estimate of P, A, and DSigma%-------------------------------------------------note='Estimated source composition matrix (P):'Phat=meanPnor %<--Point estmate for PstdP=stdPnor  %<--Uncertainty estimates for Phat[Phat_sub_rank,length_II]=idCond_check(Phat);if length_II<q*(q-1)    msg = 'Identifiability condition C1 is not satisfied for Phat.';    warning(msg)endif  prod(Phat_sub_rank==q-1)~=1    msg = 'Identifiability condition C2 is not satisfied for Phat.';    warning(msg)endnote='Estimated source contributions (A) displayed up to 10 time points:'Ahat=meanAnor; %<--Point estmate for AAhat_t1_t10=Ahat(1:10,:)stdA=stdAnor;  %<--Uncertainty estimates for AhatstdA_t1_t10=stdA(1:10,:)note='Estimated error variances (DSigma):'meanDSigma=mean(DSigmaS');DSigmahat=meanDSigma %<--Point estmate for diagonal elements of SigmastdDSigma=std(DSigmaS') %<--Uncertainty estimates for DSigmahatSigmahat=diag(DSigmahat);  %matrix of DSigmahat%-------------------------------------------------%Compute 100*(1-alpha)% (default: 95%) posterior intervals for P%-------------------------------------------------index_L=floor(alpha/2*mcsize);index_U=ceil((1-alpha/2)*mcsize);sortedPnor=sort(vecPnor');PI_P=sortedPnor([index_L index_U],:); %PI: Posterior IntervalLPI_P=reshape(PI_P(1,:),q,J); %Lower limit of PI for PUPI_P=reshape(PI_P(2,:),q,J); %Upper limit of PI for PPI_width_P=UPI_P-LPI_P;avg_P_PI_width=mean(PI_width_P); %Average (over sources) interval widths for the elemetns of P%-------------------------------------------------%Compute 95% posterior intervals for A%-------------------------------------------------sortedAnor=sort(vecAnor');PI_A=sortedAnor([index_L index_U],:);LPI_A=reshape(PI_A(1,:),T,q);  %Lower limit of PI for AUPI_A=reshape(PI_A(2,:),T,q);  %Upper limit of PI for API_width_A=UPI_A-LPI_A;avg_A_PI_width=mean(PI_width_A);  %Average (over days) interval widths for the elemetns of A%-------------------------------------------------%Compute 95% posterior intervals for DSigma%-------------------------------------------------sorted_DSigma=sort(DSigmaS');PI_DSigma=sorted_DSigma([index_L index_U],:);LPI_DSigma=PI_DSigma(1,:); %Lower limit of PI for SigmaUPI_DSigma=PI_DSigma(2,:); %Upper limit of PI for SigmaPI_width_DSigma=UPI_DSigma-LPI_DSigma; %Average interval widths for the elemetns of Sigma%----------------------------------------------------% BNFA plots: pcplot, barplot, tsplot, traceplots%----------------------------------------------------% ---------------------------------------------------------------%Principal component plots of data (Y) and source profiles (Phat)%-----------------------------------------------------------------pcplot(Y,Phat)%---------------------------------------------------------------% Barplots for elements of the estimated source profiles (Phat)% with error bars (95% posterior intervals)%---------------------------------------------------------------Phat_in_percent=Phat*100;LPI_P_in_percent=LPI_P*100;UPI_P_in_percent=UPI_P*100;if nargin<15    barplotP(Phat_in_percent,LPI_P_in_percent,UPI_P_in_percent);elseif nargin==15    %If species_name (J-dimensional vector containing the variable names) is    %available in the workspace, the following call format can also be used:    barplotP(Phat_in_percent,LPI_P_in_percent,UPI_P_in_percent,species_name);end%---------------------------------------------------------------% Time series plots of the estimated source contributions (Ahat)% with 95% posterior intervals%-------------------------------------------------------------tsplotA(Ahat,LPI_A,UPI_A)%---------------------------------------------------------------% Trace plots of MCMC samples for P, A, and DSigma% for monitoring convergence%---------------------------------------------------------------nrow=3; ncol=4; %Number of rows and columns for subplots per window (page).traceplot(nrow,ncol,PSnor,ASnor,DSigmaS)%---- Trace plots and ACF plots of the MCMC samples for the elements of P% (for monitoring convergence and autocorrelation)traceplot_ACF_P(PSnor)% Type 'close all' to close all figure windows.